
#include <iostream>
#include <fstream>
#include "stdlib.h"
#include <vector>
#include <math.h>
#include <algorithm>

#include <string>
#include <numeric>
#include <time.h>

const char global_algorithm_version[] = "V1.2.2";
char* get_target_vesion(void);


/*
@brief: 根据第一个时间戳，计算与标准时间戳的差值。
	计算逻辑：
	删除秒数据： start_tstp = start_tstp - start_tstp % 60;
	分钟除5（即300秒）取余：remainder = minutes % 300。
@param:
	input:
		start_datetime：第一个时间戳，long long
@ret:
	remainder：根据第一个时间戳计算得到余数，int。
*/

int calc_remainder(long long start_tstp);

/*
@brief: 根据第一个时间戳校正时间戳，计算时间戳编码。
	编码逻辑：将一天24小时按5分钟为间隔编码为0~287；00:00~00:04为0；00:05~00:09为1，以此类推。
	时间戳校正逻辑：原始时间+remainder+diff
@param:
	input:
		origin_tstp：输入时间数组，long long*
		N：数组长度
		remainder：根据第一个时间戳计算得到余数，int；根据分数数值除以5分钟（300秒），取余数。
	output:
		code_array:时间戳编码值数组,int*
		correct_tstp：校正后的时间戳,long long *
@ret: 状态，200：运行正常；500：运行异常
*/
int gen_timecode_correct_datetime(long long* origin_tstp, int N, int remainder, int* code_array, long long* correct_tstp);

/*
 @brief: 根据不同的糖尿病类型，将血糖值分类为极低(-2)、低(-1)、正常(0)、高(1)、极高(2)，我称之为血糖水平编码。
 @param:
		input:
			glucose：血糖值,float
			type：糖尿病类型。int,0：正常；1：1、2型糖尿病；2：妊娠糖；3：老年糖；4：自定义；默认正常。
			threshold:自定义值，包含4个值，分别为：极低阈值，低阈值，高阈值，极高阈值。仅在type为4时启用，float*
				如果自定义不需要极低阈值或极高阈值，则只需将对应阈值设置为超出血糖值的范围即可。
				例如，无需极低血糖阈值，则需threshold[0]=2.1(按照设定，血糖值不会低于2.2)；
				同理无需极高血糖阈值，则需threshold[0]=25.1.
 @ret: tir code,值为{-2，-1,0,1,2},int
*/
int gen_tir_code(float glucose, int type, float* threshold);

/*
@brief: 在gen_tir_code函数的基础上处理数组
@param:
	input:
		glucose：血糖值,float*
		type：糖尿病类型。0：正常；1：1、2型糖尿病；2：妊娠糖；3：老年糖；4：自定义。
		threshold：自定义值，包含4个值，分别为：极低阈值，低阈值，高阈值，极高阈值。仅在type为4时启用，float*
			如果自定义不需要极低阈值或极高阈值，则只需将对应阈值设置为超出血糖值的范围即可。
			例如，无需极低血糖阈值，则需threshold[0]=2.1(按照设定，血糖值不会低于2.2)；
			同理无需极高血糖阈值，则需threshold[0]=25.1.
	output:
		tir_code_array:编码后的数组，int *
@ret: 状态，200：运行正常；500：运行异常
*/
int gen_tir_code_array(float* glucose, int N, int* tir_code_array, int type, float* threshold);

/*
@brief: 计算均值。
@param:
	input:
		bg_array：血糖值数组，float*
		N:数组长度，int
@ret: 血糖均值,float
*/
float calc_mean(float* bg_array, int N);

/*
@brief: 计算标准差。
@param:
	input:
		bg_array：血糖值数组，float*
		N:数组长度，int
@ret: 血糖标准差，float
*/
float calc_std(float* bg, int N);

/*
@brief: 平均血糖值转换为预估糖化血红蛋白。
@param:
	input:
		mg：平均血糖,float
@ret: 预估糖化血红蛋白值,float
*/
float mg2eA1c(float mg);

/*
@brief: 平均血糖值转换为葡萄糖管理指标。
@param:
	input:
		mg：平均血糖,float
		flag: 血糖单位，0为mg/dL,1为mmol/L，默认为1。int
@ret: 葡萄糖管理指标值,float
*/
float mg2gmi(float mg, int flag = 1);

/*
@brief: 计算AUCmd。
@param:
	input:
		mg_median_array：中位数血糖数组,float*
		N：数组长度，默认288，int
@ret: AUCmd,float
*/
float calc_AUCmd(float* bg_median_array, int N = 288);

/*
@brief: 计算变异系数。
@param:
	input:
		sdbg：血糖标准差,float
		mg：平均血糖,float
	output:cv,float
@ret: 状态，200：运行正常；500：运行异常
*/
int calc_cv(float sdbg, float mg, float* cv);

/*
@brief: 计算平均血糖波动幅度。
@param:
	input:
		bg_array：血糖数组，float*
		N:数组长度，int
		threshold：阈值，一般取24h血糖标准差
@ret: 平均血糖波动幅度,float
*/
float calc_mage(float* bg_array, int N, float threshold);

/*
@brief: 计算最大血糖波动幅度。
@param:
	input:
		bg_array：血糖数组，float*
		N:数组长度,int
@ret: 最大血糖波动幅度,float
*/
float calc_lage(float* bg_array, int N);

/*
@brief: 计算日间血糖波动幅度。
@param:
	input:
		bg_current_array：当前血糖数据，float*
		code_current_array：当前时间编码数据,int*
		N_current：当前数据长度，int
		bg_ref_array：参考血糖数据，float*
		code_ref_array：参考时间编码数据,int*
		N_ref：参考数据长度,int
@ret: modd,float
*/
float calc_modd(float* bg_current_array, int* code_current_array, int N_current, float* bg_ref_array, int* code_ref_array, int N_ref);


/*
@brief: 数据点计数转换为时间长度。
@param:
	input:
		n：数据点个数,int
@ret: 时间段,long long
*/

long long num2dur(int n);

/*
@brief: 计算tir。
@param:
	input:
		code_array：血糖水平编码数组，int*
		N：数组长度，int
	output:
		tir:tir百分比，float*,tir[0]对应极低，tir[1]对应低，tir[2]对应正常，tir[3]对应高，tir[4]对应极高，
		tir_time:tir时间长度,long long*,同tir
@ret: 状态，200：运行正常；500：运行异常
*/
int calc_tir(int* code_array, int N, float* tir, long long* tir_time);


/*
@brief: 计算血糖事件，两个测量点时间超过（等于）即15分钟，记为1次血糖事件，持续时间为结束时间-开始时间
@param:
	input:
		bg_array:血糖数组，float*
		tir_code_array：血糖水平数组，int*
		correct_datetime_array:时间戳数组，long long*
		N:数组长度,int
	output:
		tir_type:血糖水平数组，int*
		start:开始时间,long long*
		end:结束时间,long long*
		extre_values:极值，float*
		event_num:异常血糖事件计数，int*，为1*1指针。
@ret: 状态，200：运行正常；500：运行异常
*/
int calc_event(float* bg_array,int* tir_code_array, long long* correct_datetime_array, int N,
	int* tir_type_array, long long* start_array, long long* end_array,float* extre_values, int* event_num);


/*
@brief: 计算夜间血糖事件，两个测量点时间超过（等于）即15分钟，记为1次血糖事件，持续时间为结束时间-开始时间
@param:
	input:
		bg_array:一天的血糖数组，float*
		tir_code_array：一天的血糖水平数组，int*
		correct_datetime_array:一天的时间戳数组，long long*
		N:数组长度,int
	output:
		tir_type:血糖水平数组，int*
		start:开始时间,long long*
		end:结束时间,long long*
		extre_values:极值，float*
		event_num:异常血糖事件计数，int*，为1*1指针。
@ret: 状态，200：运行正常；500：运行异常
*/
int calc_event_night(float* bg_array_day, int* tir_code_array_day, long long* correct_datetime_array_day, int N,
	int* tir_type_array, long long* start_array, long long* end_array, float* extre_values, int* event_num);


/*
@brief: 计算低血糖风险指数、高血糖风险指数
@param:
	input:
		bg_array：血糖数组
		N：数组长度
	output:
		lbgi:低血糖风险指数
		hbgi:高血糖风险指数
@ret: 状态，200：运行正常；500：运行异常
*/

int calc_lbgi_hbgi(float* bg_array, int N, float* lbgi, float* hbgi);


/*
@brief: 升序排序，直接对原数组排序
@param:
	input:
		bg_array：血糖数组，float*
		N：数组长度,int
	output:
		in_array：直接对原数组排序，float*
@ret: void
*/
void sort_value(float* in_array, int N);

/*
@brief: 计算分位数
@param:
	input:
		bg_t_array：连续时间内每天t时刻的血糖数组，float*
		p：分位点*100，如果是25%分位数，则p=25,int
@ret: 分位数，float
*/
float percentile(float* bg_t_array, int N, int p);

/*
@brief: 将数据按照时间戳分组
@param:
	input:
		bg_array：血糖数组，float*
		code_array：时间戳编码数组，int*
		N:数组长度,int
	output：
		bg_array_group：分组结果，为288*天数，float**
		code_len_array：每个时间点（编码值）对应的数据个数，int*，长度为288
@ret: 状态，200：运行正常；500：运行异常
*/
int bg_group_time(float* bg_array, int* code_array, int N, float** bg_array_group, int* code_len_array);

/*
@brief: 根据分好的组，计算agp的5条曲线
@param:
	input:
		bg_array：血糖数组，float*
		code_array：时间戳编码数组，int*
		N:数组长度，int
	output：
		per5:5%血糖数组，float*
		per25:25%血糖数组，float*
		per50:50%血糖数组，float*
		per75:75%血糖数组，float*
		per95:95%血糖数组，float*
@ret: 状态，200：运行正常；500：运行异常
*/
int gen_agp(float* bg_array, int* code_array, int N, float* per5_array, float* per25_array, float* per50_array, float* per75_array, float* per95_array);

/*
@brief: kalman滤波
@param:
	input:
		bg_array：输入的血糖值数组（分位数数组），float*
		N:数组长度
	output:
		bg_array：对指针操作，将原数组作为输出，float*
@ret: void
*/
//float* agp_kalman_filter(float* bg_array, int N);
void agp_kalman_filter(float* bg_array, int N);

/*
@brief: 数据反转
@param:
	input:
		bg_array：输入的血糖值数组（分位数数组），float*
		N:数组长度
	output:
		bg_array：对指针操作，将原数组作为输出，float*
@ret: void
*/
//float* Reversal_function(float* bg_array, int N);
void Reversal_function(float* bg_array, int N);

/*
@brief: 对agp曲线滤波,正反重复滤波14次
@param:
	input:
		bg_array：输入的血糖值数组（分位数数组），float*
		N:数组长度
	output:
		bg_array：对指针操作，将原数组作为输出，float*
@ret: void
*/
void agp_filter(float* bg_array, int N);

/*
@brief: 按天将数据分组，需要将时间按照升序排列，否则无法正确计算。
@param:
	input:
		bg_array：血糖值，float *
		N:数组长度，int
		code_array:时间编码，int*
		datetime_array:校正后时间戳，int*
	output:
		bg_group_array:血糖分组，float **
		code_group_array：时间编码分组，int **
		datetime_group_array：时间戳分组，long long **
		day_len_array：每天探头值数量，int *
		dur_days,天数,int*, 1*1
@ret: 状态，200：运行正常；500：运行异常
*/
int group_by_day(float* bg_array, int N, int* code_array, long long* datetime_array, float** bg_group_array, int** code_group_array, long long** datetime_group_array, int* day_len_array, int* dur_days);

/*
@brief: 按每日小时区间将数据分组
@param:
	input:
		bg_array：血糖值，float *
		N:数组长度，int
		code_array:时间编码，int*
	output:
		bg_group_array:血糖分组，float **
		day_len_array：小时区间探头值数量，int *
@ret: 状态，200：运行正常；500：运行异常
*/
int group_by_hourDur(float* bg_array, int N, int* code_array, float** bg_group_array, int* hour_len_array);

/*
@brief: 计算多日分时指标（原始数据部分）
@param:
	input:
		bg_array：血糖值，float *
		code_array:时间编码，int*
	output:
		multi_hour:多日分时指标， 9*24,依次为tbr、tir、tar、探头值数量、上限、下限、mg、sdbg、cv，float**. 需注意探头值数量实际为int型，为保持数组数据类型的一致性，以float型存储
@ret: 状态，200：运行正常；500：运行异常
*/
int calc_hour_data_part1(float* bg_array, int N, int* code_array, int type, float* threshold, float** multi_hour);


/*
@brief: 计算多日分时指标（agp区间）
@param:
	input:
		per5_array：5%分位数数组,采用滤波后的值，float *
		per25_array：25%分位数数组,采用滤波后的值，float *
		per50_array：50%分位数数组,采用滤波后的值，float *
		per75_array：75%分位数数组,采用滤波后的值，float *
		per95_array：95%分位数数组,采用滤波后的值，float *
		multi_hour_agp:float**,3*24,依次为，5%-95%区间，50%中位数，25%-75%区间

@ret: 状态，200：运行正常；500：运行异常
*/
int calc_hour_data_part2(float* per5_array, float* per25_array, float* per50_array, float* per75_array, float* per95_array, float** multi_hour_agp);

